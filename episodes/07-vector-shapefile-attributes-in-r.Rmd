---
title: "Explore and Plot by Shapefile Attributes"
teaching: 20
exercises: 10
questions:
- "How can I view the attributes of a spatial object?"
objectives:
- "Be able to query attributes of a spatial object."
- "Be able to subset spatial objects using specific attribute values."
- "Know how to plot a shapefile, colored by unique attribute values."
keypoints:
- "Spatial objects in sf are similar to standard data frames except for a geometry list-column."
authors: [Joseph Stachelek, Leah A. Wasser, Megan A. Jones]
---

```{r setup, echo=FALSE}
source("../bin/chunk-options.R")
source("../setup.R")
knitr_fig_path("07-")
```

```{r load-libraries, echo=FALSE, results='hide', message=FALSE}
library(raster)
library(rgdal)
library(ggplot2)
library(dplyr)
library(sf)
```

```{r load-data, echo=FALSE, results='hide'}
point_HARV <- st_read("data/NEON-DS-Site-Layout-Files/HARV/HARVtower_UTM18N.shp")
lines_HARV <- st_read("data/NEON-DS-Site-Layout-Files/HARV/HARV_roads.shp")
aoi_boundary_HARV <- st_read(
  "data/NEON-DS-Site-Layout-Files/HARV/HarClip_UTMZ18.shp")
```

> ## Things Youâ€™ll Need To Complete This Episode
> See the [lesson homepage]({{ site.baseurl }}) for detailed information about the software,
> data, and other prerequisites you will need to work through the examples in this episode.
{: .prereq}

This episode explains what shapefile attributes are and how to work with
shapefile attributes in `R`. It also covers how to identify and query shapefile
attributes, as well as subset shapefiles by specific attribute values.
Finally, we will review how to plot a shapefile according to a set of attribute
values.

## Shapefile Metadata & Attributes
When we import a shapefile into `R`, the `st_read()` function automatically
stores metadata and attributes associated with the file.

## Load the Data
We will continue using the `sf`, `raster` and `ggplot2` packages in this episode. Make sure that you have these libraries loaded.

For data, we will continue to work with the three shapefiles that we loaded in the
[Open and Plot Shapefiles in R]({{site.baseurl}}/06-vector-open-shapefile-in-r/) episode.

## Query Shapefile Metadata
Remember, as covered in
[Open and Plot Shapefiles in R]({{site.baseurl}}/06-vector-open-shapefile-in-r/),
we can view metadata associated with an `R` object using:

* `st_geometry_type()` - Describes the type of vector data stored in the object.
* `nrow()` - How many features are in this spatial object?
* object `st_bbox()` - The spatial extent (geographic area covered by) features
in the object.
* coordinate reference system (`st_crs()`) - The spatial projection that the data are
in.

Let's explore the metadata for our `point_HARV` object.

```{r view-shapefile-metadata }
st_geometry_type(point_HARV)

nrow(point_HARV)
```

Using the `raster` package, we can also view the CRS and the extent (or boundary box) of our `point_HARV` object.

```{r view-shapefile-crs }
st_crs(point_HARV)

st_bbox(point_HARV)
```

To see a summary of all of the metadata associated with our `point_HARV` object, we can view the object itself.

```{r view-object }
point_HARV
```

We can look at all of the associated data attributes by printing the contents of the `sf` object. We can use the `ncol` function to count the number of attributes associated with a spatial object too.

```{r shapefile-attributes}
# how many attributes are in our vector data object?
ncol(lines_HARV)
```

We can view the individual **name of each attribute** using the
`names` function in `R`.

```{r view-shapefile-attributes }
names(lines_HARV)
```

We could also view just the first 6 rows
of attribute values using `head(lines_HARV)` to get a preview of the data.

```{r view-shapefile-attributes-head }
head(lines_HARV)
```

> ## Challenge: Attributes for Different Spatial Classes
>
> Explore the attributes associated with the `point_HARV` and `aoi_boundary_HARV` spatial objects.
>
> 1. How many attributes does each have?
> 2. Who owns the site in the `point_HARV` data object?
> 3. Which of the following is NOT an attribute of the `point_HARV` data object?
>
>     A) Latitude      B) County     C) Country
>
> > ## Answers
> >
> > ```{r challenge-code-attributes-classes, echo=TRUE}
> > # 1
> > ncol(point_HARV)
> > ncol(aoi_boundary_HARV)
> > 
> > # 2
> > head(point_HARV)
> > 
> > # 3
> > names(point_HARV)
> > ```
> {: .solution}
{: .challenge}

## Explore Values within One Attribute
We can explore individual values stored within a particular attribute.
Comparing attributes to a spreadsheet or a `data.frame`, this is similar
to exploring values in a column. We did this with the `gapminder` dataframe in [an earlier lesson](https://datacarpentry.org/r-intro-geospatial/05-data-subsetting/index.html). For spatial objects, we can use the same syntax: `objectName$attributeName`.

We can see the contents of the `TYPE` field of our lines shapefile:

```{r explore-attribute-values }
lines_HARV$TYPE
```

To see only unique values within the `TYPE` field, we can use the
`levels()` function for extracting the possible values of a
categorical variable. The special term for categorical variables
within `R` is `factor`. We worked with factors a little bit in [a previous lesson](https://datacarpentry.org/r-intro-geospatial/03-data-structures-part1/index.html).

```{r explor-attribute-values-factor }
levels(lines_HARV$TYPE)
```

### Subset Shapefiles
We can also use the `objectName$attributeName` syntax to select a subset of features
from a spatial object in `R`, just like with data frames.

For example, we might be interested only in features that are of `TYPE` "footpath". Once we subset out this data, we can
use it as input to other code so that that code only operates on the
footpath lines.

```{r Subsetting-shapefiles}
footpath_HARV <- lines_HARV[lines_HARV$TYPE == "footpath",]
nrow(footpath_HARV)
```

Our subsetting operation reduces the `features` count to 2. This means
that only two feature lines in our spatial object have the attribute
"TYPE=footpath".

We can plot only the footpath lines.

```{r plot-subset-shapefile}
ggplot() + 
  geom_sf(data = footpath_HARV) + 
  ggtitle("NEON Harvard Forest Field Site \n Footpaths")
```

Interesting. Above, it appeared as if we had 2 features in our footpaths subset.
Why does the plot look like there is only one feature?

Let's adjust the colors used in our plot. If we have 2 features in our vector
object, we can plot each using a unique color by assigning a column name to the color aesthetic (`color=`). We use the syntax `aes(color = )` to do this.

```{r plot-subset-shapefile-unique-colors }
ggplot() + 
  geom_sf(data = footpath_HARV, aes(color = factor(OBJECTID))) +
  ggtitle("NEON Harvard Forest Field Site\n Footpaths")
```

Now, we see that there are in fact two features in our plot!

> ## Challenge: Subset Spatial Line Objects Part 1
> 
> Subset out all `boardwalk` from the lines layer and plot it.
>
> > ## Answers
> > 
> > ```{r challenge-code-feature-subset-1, echo=TRUE}
> > 
> > # save an object with only boardwalk lines
> > boardwalk_HARV<-lines_HARV[lines_HARV$TYPE == "boardwalk",]
> > # check number of features
> > nrow(boardwalk_HARV)
> >
> > ggplot() + 
> >   geom_sf(data = boardwalk_HARV) +
> >   ggtitle("NEON Harvard Forest Field Site\n Boardwalks")
> > 
> > ```
> {: .solution}
{: .challenge}

> ## Challenge: Subset Spatial Line Objects Part 2
>
> Subset out all `stone wall` features from the lines layer and plot it. For each plot, color each feature using a unique color.
>
> > ## Answer
> >
> > ```{r challenge-code-feature-subset-2, echo=TRUE}
> >
> > # save an object with only stone wall lines
> > stoneWall_HARV <- lines_HARV[lines_HARV$TYPE == "stone wall",]
> > # check number of features
> > nrow(stoneWall_HARV)
> >
> > ggplot() +
> >   geom_sf(data = stoneWall_HARV, aes(color = factor(OBJECTID))) +
> >   ggtitle("NEON Harvard Forest Field Site\n Stonewalls")
> >
> > ```
> {: .solution}
{: .challenge}


## Customize Plots
In the examples above, `ggplot()` automatically selected colors for
each line based on a default color order. If we don't like those
default colors, we can create a `vector` of colors - one for each
feature.

To create this vector we can use the following syntax:

`c("colorOne", "colorTwo", "colorThree")[object$factor]`

Note in the above example we have

1. a vector of colors - one for each factor value (unique attribute value)
2. the attribute itself (`[object$factor]`) of class `factor`.

First we need to check and see how many unique levels our
factor has:

``` {r palette-and-plot}
levels(lines_HARV$TYPE)
```

Then we can create a pallet of four colors, one for each
feature in our vector object.

```{r}
roadColors <- c("blue", "green", "grey", "purple")[lines_HARV$TYPE]
```

We can then tell `ggplot` to use these colors when we plot the data.

```{r}
ggplot() +
  geom_sf(data = lines_HARV, color = roadColors) + 
  ggtitle("NEON Harvard Forest Field Site\n Roads & Trails")
```

### Adjust Line Width
We can also adjust the width of our plot lines using the `size` argument. 
We can set all lines to be thicker or thinner using `size = `.

```{r adjust-line-width}
ggplot() + 
  geom_sf(data = lines_HARV, color = roadColors, size = 3) + 
  ggtitle("NEON Harvard Forest Field Site\n Roads & Trails\n All Lines Thickness=3")
```

If we want a unique line width for each factor level or attribute category
in our spatial object, we can use the same syntax that we used for colors, above.

`size = c("widthOne", "widthTwo", "widthThree")[object$factor]`

We already know that we have four different `TYPE` levels in the
lines_HARV object, so we will set four different line widths.

```{r line-width-unique }
lineWidths <- (c(1, 2, 3, 4))[lines_HARV$TYPE]
```

We can use those line widths when we plot the data.

```{r}
ggplot() +
  geom_sf(data = lines_HARV, color = roadColors, size = lineWidths) + 
  ggtitle("NEON Harvard Forest Field Site\n Roads & Trails \n Line width varies by TYPE Attribute Value")
```

> ## Challenge: Plot Line Width by Attribute
> 
> In the example above, we set the line widths to be 1, 2, 3, and 4.
> Because `R` orders factor levels alphabetically by default,
> this gave us a plot where woods roads (the last factor level)
> were the thickest and boardwalks were the thinest.
>
> Let's create another plot where we show the different line types
> with the following thicknesses:
>
> 1. woods road size = 6
> 2. boardwalks size = 1
> 3. footpath size = 3
> 4. stone wall size = 2
> 
> > ## Answers
> > 
> > First we need to look at the levels of our factor to see
> > what order the road types are in:
> >
> > ```{r}
> > levels(lines_HARV$TYPE)
> > ```
> >
> > We then can create our `lineWidth` vector setting each of the
> > levels to the desired thickness.
> >
> > ```{r}
> > lineWidth <- c(1, 3, 2, 6)[lines_HARV$TYPE]
> > ```
> >
> > Now we can create our plot.
> >
> > ```{r}
> > ggplot() +
> >   geom_sf(data = lines_HARV, size = lineWidth) +
> >   ggtitle("NEON Harvard Forest Field Site \n Roads & Trails \n Line width varies by Type Attribute Value")
> > ```
> {: .solution}
{: .challenge}

### Add Plot Legend
We can add a legend to our plot too. When we add a legend, we use the following
elements to specify labels and colors:

* `bottomright`: We specify the **location** of our legend by using a default
keyword. We could also use `top`, `topright`, etc.
* `levels(objectName$attributeName)`: Label the **legend elements** using the
categories of `levels` in an attribute (e.g., levels(lines_HARV$TYPE) means use
the levels boardwalk, footpath, etc).
* `fill=`: apply unique **colors** to the boxes in our legend. `palette()` is
the default set of colors that `R` applies to all plots.

Let's add a legend to our plot. We will use the `roadPalette` object
that we created above to color the legend.

```{r add-legend-to-plot }
ggplot() + 
  geom_sf(data = lines_HARV, color = roadColors) +
  scale_color_manual(values = roadPalette) + 
  ggtitle("NEON Harvard Forest Field Site\n Roads & Trails\n Default Legend")
```

We can change the appearance of our legend by manually setting
different parameters.

* `legend.text`: change the font size
* `legend.box.background`: add an outline box

```{r modify-legend-plot }
ggplot() + 
  geom_sf(data = lines_HARV, aes(color = factor(TYPE))) +
  scale_color_manual(values = roadPalette) + 
  theme(legend.text = element_text(size = 20), 
        legend.box.background = element_rect()) + 
  ggtitle("NEON Harvard Forest Field Site\n Roads & Trails \n Modified Legend")
```

We can modify the colors used to plot our lines by creating a new color vector,
directly in the plot code too rather than creating a separate object.

`col=(newColors)[lines_HARV$TYPE]`

```{r plot-different-colors}
newColors <- c("springgreen", "blue", "magenta", "orange")

ggplot() + 
  geom_sf(data = lines_HARV, aes(color = factor(TYPE))) + 
  scale_color_manual(values = newColors) + 
  theme(legend.text = element_text(size = 20), 
        legend.box.background = element_rect()) + 
  ggtitle("NEON Harvard Forest Field Site\n Roads & Trails \n Pretty Colors")
```

> ## Data Tip
> You can modify the default R color palette
> using the palette method. For example `palette(rainbow(6))` or
> `palette(terrain.colors(6))`. You can reset the palette colors using
> `palette("default")`!
{: .callout}

> ## Challenge: Plot Lines by Attribute
> 
> Create a plot that emphasizes only roads where bicycles and horses are allowed.
> To emphasize this, make the lines where bicycles are not allowed THINNER than
> the roads where bicycles are allowed.
> NOTE: this attribute information is located in the `lines_HARV$BicyclesHo`
> attribute.
> 
> Be sure to add a title and legend to your map. You might consider a color
> palette that has all bike/horse-friendly roads displayed in a bright color. All
> other lines can be grey.
> 
> > ## Answers
> >
> >
> > First we need to make sure that the `BicyclesHo` attribute is a
> > factor and check how many levels it has.
> >
> > ```{r}
> > class(lines_HARV$BicyclesHo)
> > levels(lines_HARV$BicyclesHo)
> > ```
> >
> > Next, we will create a new object `lines_removeNA` that removes missing values.
> >
> > ```{r}
> > lines_removeNA <- lines_HARV[na.omit(lines_HARV$BicyclesHo),]
> > ```
> >
> > In our plot, we will set colors so that only the allowed roads
> > are magenta, and we will set line width so that the first
> > factor level is thicker than the others.
> >
> > ```{r}
> > ggplot() + 
> >   geom_sf(data = lines_removeNA, aes(color = BicyclesHo), size = 2) + 
> >   scale_color_manual(values = "magenta") +
> >   geom_sf(data = lines_HARV, size = 0.5) + 
> >   ggtitle("NEON Harvard Forest Field Site\n Roads Where Bikes and Horses Are Allowed")
> > ```
> {: .solution}
{: .challenge}

> ## Challenge: Plot Polygon by Attribute
>
> 1. Create a map of the state boundaries in the United States using the data
> located in your downloaded data folder: `NEON-DS-Site-Layout-Files/US-Boundary-Layers\US-State-Boundaries-Census-2014`.
> Apply a fill color to each state using its `region` value. Add a legend.
>
> > ## Answers
> >
> > ``` {r, warning=FALSE, echo=TRUE}
> > ## 1
> > # Read the shapefile file
> > state_boundary_US <- st_read("data/NEON-DS-Site-Layout-Files/US-Boundary-Layers/US-State-Boundaries-Census-2014.shp")
> >
> > # how many levels?
> > levels(state_boundary_US$region)
> > colors <- c("purple", "springgreen", "yellow", "brown", "grey")
> > colors
> >
> > ggplot() +
> >   geom_sf(data = state_boundary_US, aes(color = region)) +
> >   scale_color_manual(values = colors) +
> >   ggtitle("Contiguous U.S. State Boundaries \n 50 Colors")
> > ```
> {: .solution}
{: .challenge}
