---
title: "Manipulate Raster Data in R"
teaching: 20
exercises: 10
questions:
- "How can I crop raster objects to vector objects, and extract the summary of raster pixels?"
objectives:
- "Be able to crop a raster to the extent of a vector layer."
- "Be able to extract values from raster that correspond to a vector file overlay."
keypoints:
- ""
---

```{r setup, echo=FALSE}
source("../bin/chunk-options.R")
source("../setup.R")
knitr_fig_path("11-")
```

```{r load-libraries, echo = FALSE, results='hide'}
library(sf)
library(raster)
library(rgdal)
library(ggplot2)
library(dplyr)
```


```{r load-data, echo = FALSE, results='hide'}
# Learners will have this data loaded from earlier episodes
# shapefiles
point_HARV <- st_read("data/NEON-DS-Site-Layout-Files/HARV/HARVtower_UTM18N.shp")
lines_HARV <- st_read("data/NEON-DS-Site-Layout-Files/HARV/HARV_roads.shp")
aoi_boundary_HARV <- st_read(
  "data/NEON-DS-Site-Layout-Files/HARV/HarClip_UTMZ18.shp")

# CHM (calculated)
DSM_HARV <- raster("data/NEON-DS-Airborne-Remote-Sensing/HARV/DSM/HARV_dsmCrop.tif")
DSM_HARV_df <- rasterToPoints(DSM_HARV, spatial = TRUE) %>%
data.frame()

DTM_HARV <- raster("data/NEON-DS-Airborne-Remote-Sensing/HARV/DTM/HARV_dtmCrop.tif")
DTM_HARV_df <- rasterToPoints(DTM_HARV, spatial = TRUE) %>%
data.frame()

CHM_HARV <- DSM_HARV - DTM_HARV

CHM_HARV_df <- CHM_HARV  %>% 
   rasterToPoints(., spatial = TRUE) %>% 
   data.frame()

# plot locations
plot_locations_HARV <-
  read.csv("data/NEON-DS-Site-Layout-Files/HARV/HARV_PlotLocations.csv")
utm18nCRS <- st_crs(point_HARV)
plot_locations_sp_HARV <- st_as_sf(plot_locations_HARV, coords = c("easting", "northing"), crs = utm18nCRS)
```

> ## Things Youâ€™ll Need To Complete This Episode
> See the [lesson homepage]({{ site.baseurl }}) for detailed information about the software,
> data, and other prerequisites you will need to work through the examples in this episode.
{: .prereq}

This episode explains how to crop a raster using the extent of a vector
shapefile. We will also cover how to extract values from a raster that occur
within a set of polygons, or in a buffer (surrounding) region around a set of
points.

## Crop a Raster to Vector Extent
We often work with spatial layers that have different spatial extents.

<figure>
    <a href="{{ site.baseurl }}/images/dc-spatial-vector/spatial_extent.png">
    <img src="{{ site.baseurl }}/images/dc-spatial-vector/spatial_extent.png"></a>
    <figcaption>The spatial extent of a shapefile or R spatial object represents
    the geographic "edge" or location that is the furthest north, south east and
    west. Thus is represents the overall geographic coverage of the spatial
    object. Image Source: National Ecological Observatory Network (NEON)
    </figcaption>
</figure>

The graphic below illustrates the extent of several of the spatial layers that
we have worked with in this workshop:

* Area of interest (AOI) -- blue
* Roads and trails -- purple
* Vegetation plot locations -- black
* A canopy height model (CHM) in GeoTIFF format -- green

```{r view-extents, echo=FALSE}
# create CHM as a shapefile
CHM_HARV_sp <- st_as_sf(CHM_HARV_df, coords = c("x", "y"), crs = utm18nCRS)
# approximate the boundary box with random sample of raster points
CHM_rand_sample = sample_n(CHM_HARV_sp, 10000)
```

```{r, echo = FALSE}
ggplot() + 
  geom_sf(data = st_convex_hull(st_union(CHM_rand_sample)), fill = "green") +
  geom_sf(data = st_convex_hull(st_union(lines_HARV)), fill = "purple", aes(alpha = 0.1)) +
  geom_sf(data = aoi_boundary_HARV, fill = "blue") +
  geom_sf(data = st_convex_hull(st_union(plot_locations_sp_HARV)), fill = "black") + 
  theme(legend.position = "none")
```

```{r reset-par, results="hide", echo=FALSE }
dev.off()
```

Frequent use cases of cropping a raster file include reducing file size and
creating maps. Sometimes we have a raster file that is much larger than our
study area or area of interest. It is often more efficient to crop the
raster to the extent of our study area to reduce file sizes as we process
our data. Cropping a raster can also be useful when creating pretty maps so
that the raster layer matches the extent of the desired vector layers.

## Crop a Raster Using Vector Extent
We can use the `crop()` function to crop a raster to the extent of another spatial
object. To do this, we need to specify the raster to be cropped and the spatial
object that will be used to crop the raster. `R` will use the `extent` of the
spatial object as the cropping boundary. To illustrate this, we will
start by plotting the full extent of the CHM data. 

```{r Crop-by-vector-extent}
ggplot() +
      geom_raster(data = CHM_HARV_df, aes(x = x, y = y, fill = layer)) + 
     scale_fill_gradientn(name = "Canopy Height", colors = terrain.colors(10))
```

Next we create a new object with only the portion of the CHM data
that falls within the boundaries of the AOI. 

```{r}
CHM_HARV_Crop <- crop(x = CHM_HARV, y = as(aoi_boundary_HARV, "Spatial"))

CHM_HARV_Crop_df <- raster::as.data.frame(CHM_HARV_Crop, xy = TRUE)
```

Now we can plot the cropped CHM data, along with a boundary box showing the full CHM 
extent.

```{r}

ggplot() +
  geom_sf(data = st_convex_hull(st_union(CHM_rand_sample)), color = "green") + 
  geom_raster(data = CHM_HARV_Crop_df, aes(x = x, y = y, fill = layer)) + 
     scale_fill_gradientn(name = "Canopy Height", colors = terrain.colors(10)) + 
  ggtitle("LiDAR CHM - Cropped\nNEON Harvard Forest Field Site")
```

The plot above shows that the full CHM extent (plotted in green) is
much larger than the resulting cropped raster. Our new cropped CHM now has the
same extent as the `aoi_boundary_HARV` object that was used as a crop extent
(blue border below).

```{r view-crop-extent, echo=FALSE}
ggplot() + 
    geom_sf(data = aoi_boundary_HARV, color = "blue") + 
  geom_raster(data = CHM_HARV_Crop_df, aes(x = x, y = y, fill = layer)) + 
     scale_fill_gradientn(name = "Canopy Height", colors = terrain.colors(10)) + 
  ggtitle("LiDAR CHM - Cropped\nNEON Harvard Forest Field Site")
```

We can look at the extent of all of our other objects for this field site.

``` {r view-extent}
extent(chm_HARV)
extent(chm_HARV_Crop)
st_bbox(aoi_boundary_HARV)
```

Which object has the largest extent?  Our plot location extent is not the
largest but is larger than the AOI Boundary. It would be nice to see our
vegetation plot locations plotted on top of the Canopy Height Model information.

> ## Challenge: Crop to Vector Points Extent
> 
> 1. Crop the Canopy Height Model to the extent of the study plot locations.
> 2. Plot the vegetation plot location points on top of the Canopy Height Model.
> 
> > ## Answers
> > 
> > ```{r challenge-code-crop-raster-points, include=TRUE, results="hide", echo=TRUE}
> > 
> > CHM_plots_HARVcrop <- crop(x = CHM_HARV, y = as(plot_locations_sp_HARV, "Spatial"))
> > 
> > CHM_plots_HARVcrop_df <- raster::as.data.frame(CHM_plots_HARVcrop, xy = TRUE)
> > 
> > ggplot() + 
> >   geom_raster(data = CHM_plots_HARVcrop_df, aes(x = x, y = y, fill = layer)) + 
> >   scale_fill_gradientn(name = "Canopy Height", colors = terrain.colors(10)) + 
> >   geom_sf(data = plot_locations_sp_HARV) + 
> >   ggtitle("Study Plot Locations\n NEON Harvard Forest")
> > ```
> {: .solution}
{: .challenge}

In the plot above, created in the challenge, all the vegetation plot locations
(black dots) appear on the Canopy Height Model raster layer except for one. One is
situated on the blank space to the left of the map. Why?

A modification of the first figure in this episode is below, showing the
relative extents of all the spatial objects. Notice that the extent for our
vegetation plot layer (black) extends further west than the extent of our CHM
raster (bright green). The `crop()` function will make a raster extent smaller, it
will not expand the extent in areas where there are no data. Thus, the extent of our
vegetation plot layer will still extend further west than the extent of our
(cropped) raster data (dark green).

```{r, echo = FALSE}
# create CHM_plots_HARVcrop as a shape file
CHM_plots_HARVcrop_sp <- st_as_sf(CHM_plots_HARVcrop_df, coords = c("x", "y"), crs = utm18nCRS)
# approximate the boundary box with random sample of raster points
CHM_plots_HARVcrop_sp_rand_sample = sample_n(CHM_plots_HARVcrop_sp, 10000)
```

```{r, echo = FALSE}
ggplot() + 
  geom_sf(data = st_convex_hull(st_union(CHM_rand_sample)), fill = "green") +
  geom_sf(data = st_convex_hull(st_union(lines_HARV)), fill = "purple", aes(alpha = 0.1)) +
  geom_sf(data = st_convex_hull(st_union(CHM_plots_HARVcrop_sp_rand_sample)), fill = "darkgreen") +
  geom_sf(data = st_convex_hull(st_union(plot_locations_sp_HARV)), fill = "black") + 
  geom_sf(data = aoi_boundary_HARV, fill = "blue") +
  theme(legend.position = "none")
```

## Define an Extent
So far, we have used a shapefile to crop the extent of a raster dataset. Alternatively,
we can also the
`extent()` function to define an extent to be used as a cropping
boundary. This creates a new object of class `Extent`. Here we will 
provide the `extent()`
function our xmin, xmax, ymin, and ymax (in that order). 

```{r hidden-extent-chunk}
new.extent <- extent(732161.2, 732238.7, 4713249, 4713333)
class(new.extent)
```

> ## Data Tip
> The `extent()` function can be created from a numeric vector (as shown above),
> a matrix, or a list. For more details see the `extent()` function help file. 
> * `??raster::extent`
> * More on the [extent class in `R`](http://www.inside-r.org/packages/cran/raster/docs/extent).
{: .callout}

Once we have defined our new extent, we can use the `crop()` function to crop our
raster to this extent object.

```{r crop-using-drawn-extent}
CHM_HARV_manualCrop <- crop(x = CHM_HARV, y = new.extent)
```

To plot this data using `ggplot()` we need to convert it to a dataframe. 

```{r}
CHM_HARV_manualCrop_df <- raster::as.data.frame(CHM_HARV_manualCrop, xy = TRUE)
```

Now we can plot this cropped data. We will show the AOI boundary on the same plot for scale.

```{r}
ggplot() + 
    geom_sf(data = aoi_boundary_HARV, color = "blue") +
    geom_raster(data = CHM_HARV_manualCrop_df, aes(x = x, y = y, fill = layer)) + 
    scale_fill_gradientn(name = "Canopy Height", colors = terrain.colors(10)) + 
    ggtitle("NEON Harvard Forest\n Manually cropped")
```

## Extract Raster Pixels Values Using Vector Polygons

Often we want to extract values from a raster layer for particular locations -
for example, plot locations that we are sampling on the ground.

<figure>
    <a href="https://www.neonscience.org/sites/default/files/images/spatialData/BufferSquare.png">
    <img src="https://www.neonscience.org/sites/default/files/images/spatialData/BufferSquare.png"></a>
    <figcaption> Extract raster information using a polygon boundary. We can
    extract all pixel values within 20m of our x,y point of interest. These can
    then be summarized into some value of interest (e.g. mean, maximum, total).
    Source: National Ecological Observatory Network (NEON).
    </figcaption>
</figure>

To do this in `R`, we use the `extract()` function. The `extract()` function
requires:

* The raster that we wish to extract values from,
* The vector layer containing the polygons that we wish to use as a boundary or
boundaries,
* we can tell it to store the output values in a `data.frame` using
`df=TRUE` (This is optional, the default is to return a list, NOT a dataframe.) .

We will begin by extracting all canopy height pixel values located within our
`aoi_boundary_HARV` polygon which surrounds the tower located at the NEON Harvard
Forest field site.

```{r extract-from-raster}

tree_height <- extract(x = CHM_HARV,
                       y = as(aoi_boundary_HARV, "Spatial"),
                       df = TRUE)

str(tree_height)
```

When we use the `extract()` function, `R` extracts the value for each pixel located
within the boundary of the polygon being used to perform the extraction - in
this case the `aoi_boundary_HARV` object (a single polygon). In this case, the
function extracted values from 18,450 pixels.

We can create a histogram of tree height values within the boundary to better
understand the structure or height distribution of trees at our site. We will
use the column `layer` from our dataframe as our x values, as this column
represents the tree heights for each pixel.

```{r view-extract-histogram}
ggplot() + 
  geom_histogram(data = tree_height, aes(x = layer)) +
  ggtitle("Histogram of CHM Height Values (m) \nNEON Harvard Forest Field Site") +
  xlab("Tree Height") + 
  ylab("Frequency of Pixels")
```

 We can also use the
`summary()` function to view descriptive statistics including min, max, and mean
height values. These values help us better understand vegetation at our field
site.

```{r}
summary(tree_height$layer)
```

## Summarize Extracted Raster Values

We often want to extract summary values from a raster. We can tell `R` the type
of summary statistic we are interested in using the `fun=` method. Let's extract
a mean height value for our AOI.

```{r summarize-extract }
# extract the average tree height (calculated using the raster pixels)
# located within the AOI polygon
av_tree_height_AOI <- extract(x = chm_HARV,
                              y = as(aoi_boundary_HARV, "Spatial"),
                              fun = mean,
                              df = TRUE)

# view output
av_tree_height_AOI

```

It appears that the mean height value, extracted from our LiDAR data derived
canopy height model is 22.43 meters.

##Extract Data using x,y Locations

We can also extract pixel values from a raster by defining a buffer or area
surrounding individual point locations using the `extract()` function. To do this
we define the summary method (`fun=mean`) and the buffer distance (`buffer=20`)
which represents the radius of a circular region around each point.

The units of the buffer are the same units of the data `CRS`.

<figure>
    <a href="http://neondataskills.org/images/spatialData/BufferCircular.png">
    <img src="http://neondataskills.org/images/spatialData/BufferCircular.png"></a>
    <figcaption> Extract raster information using a buffer region. All pixels
    that are touched by the buffer region are included in the extract.
    Source: National Ecological Observatory Network (NEON).
    </figcaption>
</figure>

Let's put this into practice by figuring out the average tree height in the
20m around the tower location.

```{r extract-point-to-buffer }
# what are the units of our buffer
st_crs(point_HARV)

# extract the average tree height (height is given by the raster pixel value)
# at the tower location
# use a buffer of 20 meters and mean function (fun)
av_tree_height_tower <- extract(x = chm_HARV,
                                y = as(point_HARV, "Spatial"),
                                buffer = 20,
                                fun = mean,
                                df = TRUE)

# view data
head(av_tree_height_tower)

# how many pixels were extracted
nrow(av_tree_height_tower)

```

> ## Challenge: Extract Raster Height Values For Plot Locations
> 
> Use the plot location points shapefile `HARV/plot_locations_HARV.shp` or spatial
> object `plot_locations_sp_HARV` to extract an average tree height value for the
> area within 20m of each vegetation plot location in the study area.
> 
> Create a simple plot showing the mean tree height of each plot using the `plot()`
> function in base-R.
> 
> > ## Answers
> > 
> > ```{r challenge-code-extract-plot-tHeight, include=TRUE, results="hide", echo=TRUE}
> > 
> > # first import the plot location file.
> > plot_locations_sp_HARV <- st_read("data/NEON-DS-Site-Layout-Files/HARV/PlotLocations_HARV.shp")
> > 
> > # extract data at each plot location
> > meanTreeHt_plots_HARV <- extract(x = chm_HARV,
> >                                y = as(plot_locations_sp_HARV, "Spatial"),
> >                                buffer=20,
> >                                fun=mean,
> >                                df=TRUE)
> > 
> > # view data
> > meanTreeHt_plots_HARV
> > 
> > # plot data
> > plot(meanTreeHt_plots_HARV,
> >      main = "MeanTree Height at each Plot\nNEON Harvard Forest Field Site",
> >      xlab = "Plot ID", ylab = "Tree Height (m)",
> >      pch=16)
> > ```
> {: .solution}
{: .challenge}
